<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/styles/style.css">
    <link rel="stylesheet" href="/styles/post.css">
    <link rel="stylesheet" href="/styles/lifeline.css">
    <link rel="stylesheet" href="/styles/topbar.css">
    <title>ü™ê Etude_about_feeling</title>
    <base target="_blank">
</head>
<body>
    <div class="top">
        <div class="top-txt" ><a href="/index.html" target="_self">Tardigrade</a></div>
        <div class="top-bar">
            <span class="top-btn min"></span>
            <span class="top-btn max"></span>
            <span class="top-btn close"></span>
        </div>
    </div>
    <main>
        <h1 id="√©tude-about-feeling">√âtude about feeling</h1>
<p>Era uma noite normal, estava cansado, mas n√£o queria dormir. Decidi abrir o <em>youtube</em> e descobri um v√≠deo sobre a melhor forma de selecionar um ponto dentro de um <strong>c√≠rculo</strong> <sup>[1]</sup>.</p>
<p>Ent√£o comecei a pensar em qual seria a melhor forma de <strong>preencher um c√≠rculo</strong>, e aqui mostro o resultado.</p>
<ul>
<li><strong>Language</strong>: <em>JavaScript</em></li>
<li><strong>Libraries</strong>: <em>P5.js</em> <sup>[2]</sup></li>
</ul>
<p><br></br></p>
<hr />
<h2 id="linhas">Linhas</h2>
<p>A primeira tentativa foi escolher dois pontos aleat√≥rios na circunfer√™ncia e unir os mesmos atrav√©s de uma linha reta. Os pontos s√£o selecionados atrav√©s dos √¢ngulos, tal que <em>a ‚àà [0,2œÄ]</em>, ou seja, o √¢ngulo est√° em <em>radianos</em> <sup>[3]</sup>, e as coordenadas finais ser√£o obtidas atrav√©s da utiliza√ß√£o de <em>coordenadas polares</em><sup>[4]</sup></p>
<pre><code class="language-js">function lines(){
  let a = random(2*PI)
  let b = random(2*PI)
  
  line(r*cos(a),r*sin(a), r*cos(b), r*sin(b))
}
</code></pre>
<p><img src="/assets/etude/lines.png" alt="Lines 1" /></p>
<p><br></br></p>
<p>A segunda tentativa consistiu em escolher pontos, desta vez n√£o necess√°riamente pertencentes √† circunfer√™ncia, e unir
os mesmo atrav√©s de retas. Para escolher cada ponto, selecionei um √¢ngulo tal que  <em>a ‚àà [0,2œÄ]</em> e um raio tal que <em>r‚ÇÇ ‚àà [0,r]</em></p>
<pre><code class="language-js">function lines2(){  
  let a = random(2*PI)
  let b = random(2*PI)
  
  let r1 = random(r)
  let r2 = random(r)
  
  line(r1*cos(a), r1*sin(a), r2*cos(b), r2*sin(b))
}
</code></pre>
<p><img src="/assets/etude/lines2.png" alt="Lines 2" /></p>
<p><br></br></p>
<p>De seguida, apenas alterei a forma como os raios dos pontos s√£o selecionados, utilizando uma fun√ß√£o random diferente <strong>rand</strong> <sup>[5]</sup>.</p>
<pre><code class="language-js">function lines3(){
  let a = random(2*PI)
  let b = random(2*PI)
  
  let r1 = rand(r)
  let r2 = rand(r)
  
  line(r1*cos(a), r1*sin(a), r2*cos(b), r2*sin(b))
}
</code></pre>
<p><img src="/assets/etude/lines3.png" alt="Lines 3" /></p>
<p><br></br></p>
<h2 id="c√≠rculos">C√≠rculos</h2>
<p>Para os antigos, C√≠rculos eram perfeitos, ent√£o, porque n√£o tentar preencher um c√≠rculo com outros c√≠rculos?</p>
<p>A primeira vers√£o, come√ßa por rodar a tela num √¢ngulo aleat√≥rio a, tal que <em>a ‚àà [0,2œÄ]</em>. De seguida, escolhe um raio rr tal que <em>rr ‚àà [0,r]</em> e desenha um c√≠rculo tangente √† circunfer√™ncia original ou seja, com centro nas coordenadas <em>(r-rr, 0)</em> e raio <em>rr</em>, mas devemos nos lembrar que aplicamos previamente um raota√ß√£o de √¢ngulo <em>a</em>.</p>
<pre><code class="language-js">function circs(){
    push()
      rotate(random(2*PI))
      let rr = random(r)
  
      circle(r-rr,0,rr)
    pop()
}
</code></pre>
<p><img src="/assets/etude/circs.png" alt="Circles 1" /></p>
<p><br></br></p>
<p>A segunda vers√£o, segue o mesmo princ√≠pio da primeira, apenas alterando a forma como escolhe o raio<sup>[5]</sup>.</p>
<pre><code class="language-js">function circs2(){
    push()
      rotate(random(2*PI))
      let rr = rand(r)
  
      circle(r-rr,0,rr)
    pop()
}
</code></pre>
<p><img src="/assets/etude/circs2.png" alt="Circles 2" /></p>
<p><br></br></p>
<h2 id="pontos">Pontos</h2>
<p>O terceiro m√©todo baseia-se em desenhar pontos dentro do c√≠rculo.</p>
<p>A primeira vers√£o escolhe um <strong>√¢ngulo a</strong> e um <strong>raio rr</strong>, e atrav√©s de coordenadas polares desenha esse ponto.</p>
<pre><code class="language-js">function dots(n){
    let a = random(2*PI)
    let rr = random(r)
    
    point(rr*cos(a),rr*sin(a))
}
</code></pre>
<p><img src="/assets/etude/dots.png" alt="Dots 1" /></p>
<p><br></br></p>
<p>A segunda vers√£o escolhe um <strong>√¢ngulo a</strong>, mas a fun√ß√£o que seleciona o raio √© <strong>rand</strong> <sup>[5]</sup>.</p>
<pre><code class="language-js">function dots2(n){
    let a = random(2*PI)
    let rr = rand(r)
    point(rr*cos(a),rr*sin(a))
}
</code></pre>
<p><img src="/assets/etude/dots3.png" alt="Dots 2" /></p>
<p><br></br></p>
<p>Por fim, s√£o selecionadas <em>duas coordenadas, x e y</em>, tal que <em>x, y ‚àà [-r,r]</em>.
Este m√©todo tem o problema de alguns dos poss√≠veis pontos n√£o estarem contidos no c√≠rculo, pelo que utilizei o <em>teorema de pit√°goras</em>, para saber se a dist√¢ncia entre este ponto e o centro era menor ou igual que o raio <em>(x¬≤ + y¬≤ ‚â§ r¬≤)</em>. No caso do ponto n√£o estar contido, a fun√ß√£o seria repetida, at√© que o ponto selecionado estivesse contido no c√≠rculo.</p>
<pre><code class="language-js">function dots3(){
  while(true){
    let x = random(-r,r)
    let y = random(-r,r)
    
    if (x*x + y*y &lt;= r*r){
      point(x,y)
      return
    }
  }
}
</code></pre>
<p><img src="/assets/etude/dots2.png" alt="Dots 3" /></p>
<p><br></br></p>
<hr />
<p><em>[1]</em>: <a href="https://www.youtube.com/watch?v=4y_nmpv-9lI&amp;t=166s">V√≠deo</a></p>
<p><em>[2]</em>: <a href="https://p5js.org/">P5.js</a></p>
<p><em>[3]</em>: <a href="https://upchieve.org/blog/2021/4/18/what-are-radians">Radianos</a></p>
<p><em>[4]</em>: <a href="https://tutorial.math.lamar.edu/Classes/CalcII/PolarCoordinates.aspx">Coordenadas polares</a> s√£o um sistema de coordenadas, onde, em vez de duas coordenadas <em>x</em> e <em>y</em> temos uma coordenada <em>r (dist√¢ncia √† origem)</em> e uma coordenada <em>œÜ (√¢ngulo feito com o semi-eixo positivo Ox)</em>. Este tipo de coordenadas facilida o estudo de movimentos circulares por exemplo e a convers√£o entre coordenadas polares e cartezianas pode ser feita da seguinte forma:</p>
<ul>
<li>
<p>Polares ‚Üí Cartezianas:</p>
<ul>
<li><em>x = r ¬∑ cos(œÜ)</em></li>
<li><em>y = r ¬∑ sin(œÜ)</em></li>
</ul>
</li>
<li>
<p>Cartezianas ‚Üí Polares:</p>
<ul>
<li><em>r = ‚àö(x¬≤ + y¬≤)</em></li>
<li><em>œÜ =</em>
<ul>
<li><em>arctan(y/x) if x &gt; 0</em></li>
<li><em>arctan(œÄ + y/x) if x &lt; 0</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>[5]</em>: a fun√ß√£o rand foi definida por mim da seguinte forma:</p>
<pre><code class="language-js">function rand(m){
  return sqrt(random(m) * random(m))
}
</code></pre>
<p>Ou seja, utilizando <strong>‚àö(m‚ÇÅ+m‚ÇÇ)</strong>, onde m‚ÇÅ e m‚ÇÇ s√£o n√∫meros aleat√≥rios tal que: <strong>m‚ÇÅ,m‚ÇÇ ‚àà [0,m]</strong></p>

    </main>

    <div class="life-line">
        <div class="line">
            <span class="life-line-start">
                <span class="life-line-color"></span>
                Etude_about_feeling.lua
            </span>

        </div>
    </div>
</body>
</html>